<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Representative Paper Finder</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;0,700;1,400&family=DM+Sans:ital,wght@0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        :root {
            --ink: #1a1a1f;
            --ink-light: #3d3d47;
            --paper: #f7f5f0;
            --paper-warm: #ede9df;
            --accent: #c9553d;
            --accent-hover: #a84430;
            --gold: #b8860b;
            --gold-light: #d4a845;
            --success: #2d5a3f;
            --border: rgba(26, 26, 31, 0.12);
            --shadow-soft: 0 2px 20px rgba(26, 26, 31, 0.08);
            --shadow-medium: 0 8px 40px rgba(26, 26, 31, 0.12);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 18px;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'DM Sans', -apple-system, sans-serif;
            background: var(--paper);
            color: var(--ink);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 1000;
        }

        /* Header */
        header {
            padding: 2rem 0;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, var(--paper-warm) 0%, var(--paper) 100%);
        }

        .header-inner {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-mark {
            width: 48px;
            height: 48px;
            background: var(--ink);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: rotate(-3deg);
            box-shadow: var(--shadow-soft);
        }

        .logo-mark svg {
            width: 28px;
            height: 28px;
            stroke: var(--paper);
        }

        .logo-text {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .edition {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-style: italic;
            font-size: 0.85rem;
            color: var(--ink-light);
        }

        /* Main content */
        main {
            max-width: 900px;
            margin: 0 auto;
            padding: 4rem 2rem 6rem;
        }

        /* Hero section */
        .hero {
            text-align: center;
            margin-bottom: 4rem;
            animation: fadeUp 0.8s ease-out;
        }

        @keyframes fadeUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hero h1 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 1.5rem;
            letter-spacing: -0.02em;
        }

        .hero h1 span {
            display: block;
            font-style: italic;
            font-weight: 400;
            color: var(--accent);
        }

        .hero-subtitle {
            font-size: 1.1rem;
            color: var(--ink-light);
            max-width: 500px;
            margin: 0 auto;
        }

        /* Decorative line */
        .decorative-line {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 3rem 0;
        }

        .decorative-line::before,
        .decorative-line::after {
            content: '';
            flex: 1;
            max-width: 120px;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border), transparent);
        }

        .decorative-line svg {
            width: 20px;
            height: 20px;
            fill: var(--gold);
            opacity: 0.6;
        }

        /* Steps container */
        .steps-container {
            position: relative;
        }

        /* Step */
        .step {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 2.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-soft);
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: stepFadeIn 0.5s ease-out backwards;
        }

        .step:nth-child(1) { animation-delay: 0.1s; }
        .step:nth-child(2) { animation-delay: 0.2s; }
        .step:nth-child(3) { animation-delay: 0.3s; }

        @keyframes stepFadeIn {
            from {
                opacity: 0;
                transform: translateY(15px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .step::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent);
            transform: scaleY(0);
            transform-origin: top;
            transition: transform 0.3s ease;
        }

        .step.active::before {
            transform: scaleY(1);
        }

        .step.completed {
            opacity: 0.6;
        }

        .step.completed::before {
            background: var(--success);
            transform: scaleY(1);
        }

        .step.hidden {
            display: none;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .step-number {
            width: 36px;
            height: 36px;
            border: 2px solid var(--ink);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 700;
            font-size: 1rem;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .step.completed .step-number {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        .step.completed .step-number::after {
            content: 'âœ“';
        }

        .step.completed .step-number span {
            display: none;
        }

        .step-title {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.4rem;
            font-weight: 600;
        }

        .step-content {
            padding-left: 52px;
        }

        /* Form elements */
        .input-group {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .input-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--ink-light);
            margin-bottom: 0.5rem;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 1rem 1.25rem;
            font-family: 'DM Sans', sans-serif;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 6px;
            background: var(--paper);
            color: var(--ink);
            transition: all 0.2s ease;
            appearance: none;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: var(--ink);
            box-shadow: 0 0 0 4px rgba(26, 26, 31, 0.08);
        }

        input[type="text"]::placeholder {
            color: #9a9a9a;
        }

        /* Custom select arrow */
        .select-wrapper {
            position: relative;
        }

        .select-wrapper::after {
            content: '';
            position: absolute;
            right: 1.25rem;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid var(--ink);
            pointer-events: none;
        }

        /* Range slider */
        .range-container {
            margin-bottom: 1.5rem;
        }

        .range-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 0.75rem;
        }

        .range-value {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--paper-warm);
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--ink);
            cursor: pointer;
            box-shadow: var(--shadow-soft);
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: var(--ink);
            cursor: pointer;
            box-shadow: var(--shadow-soft);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            font-family: 'DM Sans', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: var(--ink);
            color: white;
        }

        .btn-primary:hover {
            background: var(--ink-light);
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-accent {
            background: var(--accent);
            color: white;
        }

        .btn-accent:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .btn-outline {
            background: transparent;
            color: var(--ink);
            border: 2px solid var(--ink);
        }

        .btn-outline:hover {
            background: var(--ink);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn svg {
            width: 18px;
            height: 18px;
        }

        /* Loading state */
        .btn.loading {
            pointer-events: none;
        }

        .btn.loading .btn-text {
            opacity: 0;
        }

        .btn.loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results card */
        .results-card {
            background: linear-gradient(135deg, var(--ink) 0%, #2a2a35 100%);
            color: white;
            border-radius: 12px;
            padding: 3rem;
            position: relative;
            overflow: hidden;
            animation: resultsFadeIn 0.6s ease-out;
        }

        @keyframes resultsFadeIn {
            from {
                opacity: 0;
                transform: scale(0.98);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .results-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(201, 85, 61, 0.15) 0%, transparent 70%);
            pointer-events: none;
        }

        .results-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 100px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1.5rem;
        }

        .results-badge svg {
            width: 14px;
            height: 14px;
            fill: var(--gold-light);
        }

        .results-title {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.8rem;
            font-weight: 600;
            line-height: 1.3;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .results-abstract {
            font-size: 0.95rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.8);
            border-left: 2px solid var(--accent);
            padding-left: 1.5rem;
            margin-bottom: 2rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .results-abstract::-webkit-scrollbar {
            width: 4px;
        }

        .results-abstract::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .results-abstract::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .results-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(212, 168, 69, 0.15);
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--gold-light);
            margin-bottom: 1.5rem;
        }

        .results-info svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .results-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .btn-light {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-light:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Author dropdown item styling */
        .author-item {
            padding: 0.25rem 0;
        }

        /* Status messages */
        .status {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 1.25rem;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-top: 1rem;
            animation: statusFade 0.3s ease;
        }

        @keyframes statusFade {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .status-loading {
            background: rgba(26, 26, 31, 0.05);
            color: var(--ink-light);
        }

        .status-loading::before {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--ink);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .status-error {
            background: rgba(201, 85, 61, 0.1);
            color: var(--accent);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            border-top: 1px solid var(--border);
            font-size: 0.85rem;
            color: var(--ink-light);
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Responsive */
        @media (max-width: 640px) {
            html {
                font-size: 16px;
            }

            .step {
                padding: 1.5rem;
            }

            .step-content {
                padding-left: 0;
                padding-top: 1rem;
            }

            .results-card {
                padding: 2rem 1.5rem;
            }

            .results-actions {
                flex-direction: column;
            }

            .btn {
                justify-content: center;
            }
        }

        /* Smooth transitions for dynamic content */
        .fade-enter {
            animation: fadeUp 0.4s ease-out;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-inner">
            <div class="logo">
                <div class="logo-mark">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                    </svg>
                </div>
                <div>
                    <div class="logo-text">Representative Paper</div>
                    <div class="edition">Research Discovery Tool</div>
                </div>
            </div>
        </div>
    </header>

    <main>
        <section class="hero">
            <h1>
                Find the Paper That
                <span>Defines a Researcher</span>
            </h1>
            <p class="hero-subtitle">
                Discover the most representative publication in any researcher's body of work using semantic analysis.
            </p>
        </section>

        <div class="decorative-line">
            <svg viewBox="0 0 24 24"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/></svg>
        </div>

        <div class="steps-container">
            <!-- Step 1: Search -->
            <div class="step active" id="step1">
                <div class="step-header">
                    <div class="step-number"><span>1</span></div>
                    <h2 class="step-title">Search for a Researcher</h2>
                </div>
                <div class="step-content">
                    <div class="input-group">
                        <label class="input-label" for="researcher-name">Researcher Name</label>
                        <input
                            type="text"
                            id="researcher-name"
                            placeholder="e.g., Yann LeCun, Geoffrey Hinton..."
                            autocomplete="off"
                        >
                    </div>
                    <button class="btn btn-primary" id="search-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"/>
                            <path d="M21 21l-4.35-4.35"/>
                        </svg>
                        <span class="btn-text">Search</span>
                    </button>
                    <div id="search-status"></div>
                </div>
            </div>

            <!-- Step 2: Select Author -->
            <div class="step hidden" id="step2">
                <div class="step-header">
                    <div class="step-number"><span>2</span></div>
                    <h2 class="step-title">Select the Author</h2>
                </div>
                <div class="step-content">
                    <div class="input-group">
                        <label class="input-label" for="author-select">Choose from results</label>
                        <div class="select-wrapper">
                            <select id="author-select">
                                <option value="">Select an author...</option>
                            </select>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="confirm-author-btn" disabled>
                        <span class="btn-text">Continue</span>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 12h14M12 5l7 7-7 7"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Step 3: Configure & Find -->
            <div class="step hidden" id="step3">
                <div class="step-header">
                    <div class="step-number"><span>3</span></div>
                    <h2 class="step-title">Find Representative Paper</h2>
                </div>
                <div class="step-content">
                    <div class="range-container">
                        <div class="range-header">
                            <label class="input-label" for="years-slider">Time window</label>
                            <span class="range-value"><span id="years-value">5</span> years</span>
                        </div>
                        <input
                            type="range"
                            id="years-slider"
                            min="1"
                            max="10"
                            value="5"
                        >
                    </div>
                    <button class="btn btn-accent" id="find-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                        </svg>
                        <span class="btn-text">Analyze Publications</span>
                    </button>
                    <div id="find-status"></div>
                </div>
            </div>

            <!-- Results -->
            <div class="step hidden" id="results-step">
                <div class="results-card">
                    <div class="results-badge">
                        <svg viewBox="0 0 24 24"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/></svg>
                        Representative Paper
                    </div>
                    <h3 class="results-title" id="result-title">Loading...</h3>
                    <div class="results-abstract" id="result-abstract">Loading...</div>
                    <div class="results-info hidden" id="result-info">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4M12 8h.01"/>
                        </svg>
                        <span id="result-info-text"></span>
                    </div>
                    <div class="results-actions">
                        <button class="btn btn-light" id="start-over-btn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M1 4v6h6M23 20v-6h-6"/>
                                <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/>
                            </svg>
                            <span class="btn-text">Start Over</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <p>Powered by <a href="https://openalex.org" target="_blank">OpenAlex</a> &amp; <a href="https://huggingface.co" target="_blank">HuggingFace</a></p>
    </footer>

    <script>
        // ============================================================================
        // Configuration
        // ============================================================================
        const CONFIG = {
            OPENALEX_BASE: 'https://api.openalex.org',
            HF_MODEL: 'sentence-transformers/allenai-specter',
            MAX_PAPERS: 25,
            // For production, proxy HF calls through your backend to hide the token
            // Set to your backend URL, e.g., '/api/embed' or leave null for direct HF calls
            EMBEDDING_PROXY: null, // e.g., '/api/embed'
            // Only use HF_TOKEN in dev/demo - in production, use a backend proxy!
            HF_TOKEN: null, // Set via environment or leave null for anonymous (rate-limited)
        };

        // ============================================================================
        // State
        // ============================================================================
        let selectedAuthorId = null;
        let authorsData = [];

        // ============================================================================
        // DOM Elements
        // ============================================================================
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const resultsStep = document.getElementById('results-step');

        const researcherInput = document.getElementById('researcher-name');
        const searchBtn = document.getElementById('search-btn');
        const searchStatus = document.getElementById('search-status');

        const authorSelect = document.getElementById('author-select');
        const confirmAuthorBtn = document.getElementById('confirm-author-btn');

        const yearsSlider = document.getElementById('years-slider');
        const yearsValue = document.getElementById('years-value');
        const findBtn = document.getElementById('find-btn');
        const findStatus = document.getElementById('find-status');

        const resultTitle = document.getElementById('result-title');
        const resultAbstract = document.getElementById('result-abstract');
        const resultInfo = document.getElementById('result-info');
        const resultInfoText = document.getElementById('result-info-text');
        const startOverBtn = document.getElementById('start-over-btn');

        // ============================================================================
        // Helper Functions
        // ============================================================================
        function showStatus(element, message, type = 'loading') {
            element.innerHTML = `<div class="status status-${type}">${message}</div>`;
        }

        function clearStatus(element) {
            element.innerHTML = '';
        }

        function setLoading(btn, loading) {
            if (loading) {
                btn.classList.add('loading');
                btn.disabled = true;
            } else {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        }

        function showStep(stepElement) {
            stepElement.classList.remove('hidden');
            stepElement.classList.add('fade-enter');
        }

        function hideStep(stepElement) {
            stepElement.classList.add('hidden');
        }

        function completeStep(stepElement) {
            stepElement.classList.remove('active');
            stepElement.classList.add('completed');
        }

        function activateStep(stepElement) {
            stepElement.classList.add('active');
            stepElement.classList.remove('completed');
        }

        // ============================================================================
        // OpenAlex API (Direct browser calls - CORS supported)
        // ============================================================================

        /**
         * Get current institution from author affiliations
         */
        function getCurrentInstitution(author) {
            const affiliations = author.affiliations || [];
            if (!affiliations.length) return 'Unknown institution';

            let bestAffiliation = null;
            let bestYear = 0;

            for (const aff of affiliations) {
                const years = aff.years || [];
                if (years.length) {
                    const maxYear = Math.max(...years);
                    if (maxYear > bestYear) {
                        bestYear = maxYear;
                        bestAffiliation = aff;
                    }
                }
            }

            if (bestAffiliation?.institution?.display_name) {
                return bestAffiliation.institution.display_name;
            }

            return affiliations[0]?.institution?.display_name || 'Unknown institution';
        }

        /**
         * Search for authors by name via OpenAlex API
         */
        async function searchAuthors(name) {
            const params = new URLSearchParams({
                search: name.trim(),
                per_page: '10'
            });

            const response = await fetch(`${CONFIG.OPENALEX_BASE}/authors?${params}`, {
                headers: { 'User-Agent': 'RepresentativePaperFinder/1.0' }
            });

            if (!response.ok) {
                throw new Error(`OpenAlex API error: ${response.status}`);
            }

            const data = await response.json();
            const results = data.results || [];

            return results.map(author => ({
                id: author.id,
                label: `${author.display_name || 'Unknown'} (${getCurrentInstitution(author)}, ${(author.works_count || 0).toLocaleString()} works)`
            }));
        }

        /**
         * Fetch publications for an author
         */
        async function fetchPublications(authorId, yearsBack) {
            const currentYear = new Date().getFullYear();
            const startYear = currentYear - yearsBack;

            const params = new URLSearchParams({
                filter: `author.id:${authorId},publication_year:>${startYear - 1}`,
                sort: 'publication_year:desc',
                per_page: '100'
            });

            const response = await fetch(`${CONFIG.OPENALEX_BASE}/works?${params}`);
            if (!response.ok) {
                throw new Error(`OpenAlex API error: ${response.status}`);
            }

            const data = await response.json();
            return data.results || [];
        }

        /**
         * Reconstruct abstract from OpenAlex inverted index format
         */
        function reconstructAbstract(invertedIndex) {
            if (!invertedIndex) return '';

            const words = [];
            for (const [word, positions] of Object.entries(invertedIndex)) {
                for (const pos of positions) {
                    words.push({ pos, word });
                }
            }

            words.sort((a, b) => a.pos - b.pos);
            return words.map(w => w.word).join(' ');
        }

        // ============================================================================
        // HuggingFace Inference API
        // ============================================================================

        /**
         * Get embeddings from HuggingFace Inference API
         * Note: For production, proxy this through your backend to protect the API token
         */
        async function getEmbeddings(texts) {
            // Option 1: Use backend proxy (recommended for production)
            if (CONFIG.EMBEDDING_PROXY) {
                const response = await fetch(CONFIG.EMBEDDING_PROXY, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ texts })
                });
                if (!response.ok) throw new Error('Embedding proxy error');
                return await response.json();
            }

            // Option 2: Direct HuggingFace API call (for demo/development only)
            const embeddings = [];

            for (const text of texts) {
                const response = await fetch(
                    `https://api-inference.huggingface.co/pipeline/feature-extraction/${CONFIG.HF_MODEL}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(CONFIG.HF_TOKEN && { 'Authorization': `Bearer ${CONFIG.HF_TOKEN}` })
                        },
                        body: JSON.stringify({ inputs: text, options: { wait_for_model: true } })
                    }
                );

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HuggingFace API error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();

                // Mean pooling: result is [seq_len, hidden_dim], we average over seq_len
                if (Array.isArray(result) && Array.isArray(result[0])) {
                    const pooled = result[0].map((_, i) =>
                        result.reduce((sum, token) => sum + token[i], 0) / result.length
                    );
                    embeddings.push(pooled);
                } else {
                    embeddings.push(result);
                }
            }

            return embeddings;
        }

        // ============================================================================
        // Medoid Computation (finding the most representative paper)
        // ============================================================================

        /**
         * Compute cosine similarity between two vectors
         */
        function cosineSimilarity(a, b) {
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;

            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }

            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB) + 1e-9);
        }

        /**
         * Find the medoid (most central vector) in a set of embeddings
         */
        function computeMedoid(embeddings) {
            const n = embeddings.length;
            if (n === 0) throw new Error('No embeddings provided');
            if (n === 1) return 0;

            // Compute sum of distances for each point
            const distanceSums = new Array(n).fill(0);

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const sim = cosineSimilarity(embeddings[i], embeddings[j]);
                    const dist = 1 - sim;
                    distanceSums[i] += dist;
                    distanceSums[j] += dist;
                }
            }

            // Return index with minimum total distance
            let minIdx = 0;
            let minDist = distanceSums[0];
            for (let i = 1; i < n; i++) {
                if (distanceSums[i] < minDist) {
                    minDist = distanceSums[i];
                    minIdx = i;
                }
            }

            return minIdx;
        }

        // ============================================================================
        // Main Analysis Function
        // ============================================================================

        async function findRepresentativePaper(authorId, years) {
            // Step 1: Fetch publications from OpenAlex
            const publications = await fetchPublications(authorId, years);

            if (!publications.length) {
                throw new Error('No publications found for this author in the selected time range.');
            }

            // Step 2: Extract valid publications with abstracts
            const validPubs = [];
            for (const pub of publications) {
                const title = pub.title || '';
                const abstract = reconstructAbstract(pub.abstract_inverted_index);

                if (title && abstract) {
                    validPubs.push({ title, abstract });
                }
            }

            if (!validPubs.length) {
                throw new Error('No publications with abstracts found.');
            }

            // Step 3: Limit to MAX_PAPERS
            const totalFound = validPubs.length;
            const papersToAnalyze = validPubs.slice(0, CONFIG.MAX_PAPERS);
            const info = totalFound > CONFIG.MAX_PAPERS
                ? `Note: Found ${totalFound} papers. Analyzing the ${CONFIG.MAX_PAPERS} most recent due to computational limits.`
                : null;

            // Step 4: Prepare texts and get embeddings
            const texts = papersToAnalyze.map(pub => `${pub.title}[SEP]${pub.abstract}`);

            const embeddings = await getEmbeddings(texts);

            // Step 5: Find medoid (most representative paper)
            const medoidIdx = computeMedoid(embeddings);
            const representative = papersToAnalyze[medoidIdx];

            return {
                title: representative.title,
                abstract: representative.abstract,
                info
            };
        }

        // Event handlers
        researcherInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                searchBtn.click();
            }
        });

        searchBtn.addEventListener('click', async () => {
            const name = researcherInput.value.trim();
            if (!name) return;

            setLoading(searchBtn, true);
            showStatus(searchStatus, 'Searching OpenAlex database...', 'loading');

            try {
                authorsData = await searchAuthors(name);

                if (authorsData.length === 0) {
                    showStatus(searchStatus, 'No researchers found. Try a different name.', 'error');
                    setLoading(searchBtn, false);
                    return;
                }

                // Populate dropdown
                authorSelect.innerHTML = '<option value="">Select an author...</option>';
                authorsData.forEach(author => {
                    const option = document.createElement('option');
                    option.value = author.id;
                    option.textContent = author.label;
                    authorSelect.appendChild(option);
                });

                clearStatus(searchStatus);
                completeStep(step1);
                showStep(step2);
                activateStep(step2);
                setLoading(searchBtn, false);
            } catch (error) {
                console.error('Search error:', error);
                showStatus(searchStatus, `Search failed: ${error.message}`, 'error');
                setLoading(searchBtn, false);
            }
        });

        authorSelect.addEventListener('change', () => {
            selectedAuthorId = authorSelect.value;
            confirmAuthorBtn.disabled = !selectedAuthorId;
        });

        confirmAuthorBtn.addEventListener('click', () => {
            if (!selectedAuthorId) return;

            completeStep(step2);
            showStep(step3);
            activateStep(step3);
        });

        yearsSlider.addEventListener('input', () => {
            yearsValue.textContent = yearsSlider.value;
        });

        findBtn.addEventListener('click', async () => {
            setLoading(findBtn, true);
            showStatus(findStatus, 'Fetching publications from OpenAlex...', 'loading');

            try {
                // Update status during analysis
                const updateStatus = (msg) => showStatus(findStatus, msg, 'loading');

                updateStatus('Fetching publications from OpenAlex...');

                // Wrap the find function to intercept status updates
                const publications = await fetchPublications(selectedAuthorId, parseInt(yearsSlider.value));

                if (!publications.length) {
                    throw new Error('No publications found for this author in the selected time range.');
                }

                // Extract valid publications
                const validPubs = [];
                for (const pub of publications) {
                    const title = pub.title || '';
                    const abstract = reconstructAbstract(pub.abstract_inverted_index);
                    if (title && abstract) {
                        validPubs.push({ title, abstract });
                    }
                }

                if (!validPubs.length) {
                    throw new Error('No publications with abstracts found.');
                }

                const totalFound = validPubs.length;
                const papersToAnalyze = validPubs.slice(0, CONFIG.MAX_PAPERS);
                const info = totalFound > CONFIG.MAX_PAPERS
                    ? `Note: Found ${totalFound} papers. Analyzing the ${CONFIG.MAX_PAPERS} most recent due to computational limits.`
                    : null;

                updateStatus(`Computing embeddings for ${papersToAnalyze.length} papers...`);

                const texts = papersToAnalyze.map(pub => `${pub.title}[SEP]${pub.abstract}`);
                const embeddings = await getEmbeddings(texts);

                updateStatus('Finding most representative paper...');

                const medoidIdx = computeMedoid(embeddings);
                const representative = papersToAnalyze[medoidIdx];

                resultTitle.textContent = representative.title;
                resultAbstract.textContent = representative.abstract;

                if (info) {
                    resultInfoText.textContent = info;
                    resultInfo.classList.remove('hidden');
                } else {
                    resultInfo.classList.add('hidden');
                }

                clearStatus(findStatus);
                completeStep(step3);
                showStep(resultsStep);
                setLoading(findBtn, false);
            } catch (error) {
                console.error('Analysis error:', error);
                showStatus(findStatus, `Analysis failed: ${error.message}`, 'error');
                setLoading(findBtn, false);
            }
        });

        startOverBtn.addEventListener('click', () => {
            // Reset everything
            selectedAuthorId = null;
            authorsData = [];
            researcherInput.value = '';
            authorSelect.innerHTML = '<option value="">Select an author...</option>';
            yearsSlider.value = 5;
            yearsValue.textContent = '5';
            confirmAuthorBtn.disabled = true;

            // Reset steps
            hideStep(step2);
            hideStep(step3);
            hideStep(resultsStep);

            step1.classList.remove('completed');
            step2.classList.remove('completed', 'active');
            step3.classList.remove('completed', 'active');

            activateStep(step1);

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    </script>
</body>
</html>
